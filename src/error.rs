#![allow(unused_assignments)]

use std::path::PathBuf;

use miette::Diagnostic;
use thiserror::Error;

#[derive(Debug, Error, Diagnostic)]
pub enum DicecutError {
    #[error("Template config not found at {path}")]
    #[diagnostic(help("Ensure the template directory contains a diecut.toml file"))]
    ConfigNotFound { path: PathBuf },

    #[error("Failed to parse diecut.toml")]
    #[diagnostic(help("Check the TOML syntax in your diecut.toml file"))]
    ConfigParse {
        #[source]
        source: toml::de::Error,
    },

    #[error("Invalid variable definition for '{name}': {reason}")]
    ConfigInvalidVariable { name: String, reason: String },

    #[error("Validation failed for variable '{name}': {message}")]
    ValidationFailed { name: String, message: String },

    #[error("Template rendering failed for '{file}'")]
    #[diagnostic(help("Check your Tera template syntax"))]
    RenderError {
        file: String,
        #[source]
        source: tera::Error,
    },

    #[error("Failed to render filename: {filename}")]
    FilenameRenderError {
        filename: String,
        #[source]
        source: tera::Error,
    },

    #[error("Output directory already exists: {path}")]
    #[diagnostic(help("Use --overwrite to replace the existing directory"))]
    OutputExists { path: PathBuf },

    #[error("Template directory not found: {path}")]
    #[diagnostic(help("The template must contain a 'template/' subdirectory"))]
    TemplateDirectoryMissing { path: PathBuf },

    #[error("IO error: {context}")]
    Io {
        context: String,
        #[source]
        source: std::io::Error,
    },

    #[error("Glob pattern error: {pattern}")]
    GlobPattern {
        pattern: String,
        #[source]
        source: globset::Error,
    },

    #[error("Prompt cancelled by user")]
    PromptCancelled,

    #[error("Invalid 'when' expression for variable '{name}'")]
    WhenEvaluation {
        name: String,
        #[source]
        source: tera::Error,
    },

    #[error("Invalid computed expression for variable '{name}'")]
    ComputedEvaluation {
        name: String,
        #[source]
        source: tera::Error,
    },

    #[error("Invalid template abbreviation: {input}")]
    #[diagnostic(help("Supported abbreviations: gh:user/repo, gl:user/repo, cb:user/repo"))]
    InvalidAbbreviation { input: String },

    #[error("Hook '{hook}' failed: {message}")]
    #[diagnostic(help("Check the shell command in your hooks configuration"))]
    HookError { hook: String, message: String },

    #[error("Cache metadata error: {context}")]
    #[diagnostic(help("Try clearing the cache with `diecut cache clear`"))]
    CacheMetadata { context: String },

    #[error("Unsafe URL scheme in '{url}': {reason}")]
    #[diagnostic(help("Use https:// URLs for remote templates"))]
    UnsafeUrl { url: String, reason: String },

    #[error("git is not installed")]
    #[diagnostic(help("Install git from https://git-scm.com"))]
    GitNotFound,

    #[error("Git clone failed for '{url}': {reason}")]
    #[diagnostic(help(
        "For private repos, ensure git credentials are configured: run `gh auth login` or set up SSH keys"
    ))]
    GitClone { url: String, reason: String },

    #[error("No answers file found in {path}")]
    #[diagnostic(help(
        "This project was not generated by diecut, or the .diecut-answers.toml file was deleted"
    ))]
    NoAnswerFile { path: PathBuf },

    #[error("Failed to parse answers file in {path}")]
    #[diagnostic(help("Check the TOML syntax in .diecut-answers.toml"))]
    AnswerFileParseError {
        path: PathBuf,
        #[source]
        source: toml::de::Error,
    },
}

pub type Result<T> = std::result::Result<T, DicecutError>;
