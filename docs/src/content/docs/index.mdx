---
title: diecut
description: A single-binary project template generator.
template: splash
head:
  - tag: title
    content: diecut — A single-binary project template generator
hero:
  tagline: A single-binary project template generator
  image:
    file: ../../assets/logo.svg
  actions:
    - text: Get Started
      link: /getting-started/
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/raiderrobert/diecut
      icon: external
      variant: minimal
---

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

<CardGrid>
	<LinkCard title="Single binary" description="No runtime dependencies. Download one file and go." href="/getting-started/" />
	<LinkCard title="Easy to make" description="A diecut.toml and a folder — that's a template. You just made one." href="/creating-templates/" />
	<LinkCard title="Multi-template repos" description="One repo, many templates. Use subpaths to pick the one you want." href="/using-templates/" />
	<LinkCard title="Any Git host" description="GitHub, GitLab, Codeberg — or any Git URL." href="/using-templates/" />
</CardGrid>

## Install

```bash
curl -fsSL https://diecut.dev/install.sh | sh
```

[More install options →](/getting-started/)

## Use it

```bash
diecut new gh:raiderrobert/diecut-templates/rust-cli -o my-cli
```

That's it. diecut prompts you for variables and generates a ready-to-go project.

[Learn more about using templates →](/using-templates/)

## Use cases

**[Starting a new project](/examples/personal-template/)** — You've got a stack you like. Run one command and you're in a working project, not a blank directory. Point at a GitHub repo, answer a few prompts, done.

**[Adding a new package to a monorepo](/examples/monorepo-packages/)** — Your monorepo has conventions: package layout, CI config, lint setup. Each new package should start from that baseline, not be hand-assembled. Keep a templates directory in your repo, or point at an existing well-structured package as the pattern.

**[Repeating a pattern within an existing project](/examples/repeating-patterns/)** — Most people copy a folder and manually rename things. diecut makes it intentional: pick the folder that already represents the right shape, run `diecut new ./path/to/that-folder`, and get a prompt-driven copy with variable substitution baked in. New routes, feature modules, service clients — anything you repeat.

**[Multi-file feature scaffolding](/examples/code-scaffolding/)** — Adding a new entity to an API means four files: controller, service, repository, test. The entity name appears in all of them. Copy-paste misses one; a template can't.

**[Structured content with consistent schemas](/examples/structured-content/)** — Content sites with strict frontmatter schemas drift over time: wrong field names, invented tag values, missing fields. Define the shape once in a diecut template. Whether a human fills it in interactively or an LLM passes values with `-d` flags, the output always conforms.

**[Prompt and skill templates](/examples/prompt-template/)** — You spend days getting a system prompt right. Then you need five variants of it. The craft is in the template; the personalization is mechanical. `select` variables constrain tone and persona to values the prompt was actually designed for.

## Why diecut?

I built diecut because I tend to make lots of projects for fun. I get a stack I like, and I don't like messing around with the setup. I enjoyed cookiecutter back in the day, but I found it complicating my life more than simplifying it.

I aimed to solve four things:

- **[Single binary](/getting-started/)**: I've often just wanted to download a binary and no faff with Python stuff, even though I wrote mostly Python.
- **[Easy to make](/creating-templates/)**: I wanted it to be dead simple to make templates with as few footguns as possible. So you also don't need to do complicated logic in the templates, because you can just chain conditional prompts together to get your answers. You don't even need to use almost any of the Tera templating at all and can just use conditional files feature to exclude files you don't want.
- **[Multi-template repos](/using-templates/)**: I dabble a lot in different stacks and languages, but I'd rather not have 5 different repos for my templates. This felt like a good way to organize them.
- **[Safe to try](/reference/commands/)**: sometimes I want to see what the result will look like before I commit to it, but none of the other tools out there had this feature.
